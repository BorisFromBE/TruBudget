import * as GlobalPermissionGrant from "./global_permissions_grant";
import * as GlobalPermissionGrantAll from "./global_permissions_grant_all";
import * as GlobalPermissionRevoke from "./global_permissions_revoke";
import * as GroupCreate from "./group_create";
import { registerRoutes } from "./httpd/router";
import { createBasicApp } from "./httpd/server";
import deepcopy from "./lib/deepcopy";
import logger from "./lib/logger";
import { isReady } from "./lib/readiness";
import timeout from "./lib/timeout";
import { registerNode } from "./network/controller/registerNode";
import { ensureOrganizationStream } from "./organization/organization";
import * as ProjectCreate from "./project_create";
import * as ProjectList from "./project_list";
import * as ProjectPermissionsGrant from "./project_permissions_grant";
import * as ProjectPermissionsRevoke from "./project_permissions_revoke";
import * as ProjectUpdate from "./project_update";
import * as Multichain from "./service";
import * as GetGlobalPermissionsService from "./service/global_permissions_get";
import { grantGlobalPermission } from "./service/global_permissions_grant";
import { revokeGlobalPermission } from "./service/global_permissions_revoke";
import { createGroup } from "./service/group_create";
import { getGroupsForUser } from "./service/group_query";
import { randomString } from "./service/hash";
import { createProject } from "./service/project_create";
import { listProjects } from "./service/project_list";
import { grantProjectPermission } from "./service/project_permissions_grant";
import { revokeProjectPermission } from "./service/project_permissions_revoke";
import { updateProject } from "./service/project_update";
import { ConnectionSettings } from "./service/RpcClient.h";
import { createSubproject } from "./service/subproject_create";
import { listSubprojects } from "./service/subproject_list";
import { authenticate } from "./service/user_authenticate";
import { createUser } from "./service/user_create";
import * as SubprojectCreate from "./subproject_create";
import * as SubprojectList from "./subproject_list";
import * as UserAuthenticate from "./user_authenticate";
import * as UserCreate from "./user_create";

const URL_PREFIX = "/api";
/*
 * Deal with the environment:
 */

const port: number = (process.env.PORT && parseInt(process.env.PORT, 10)) || 8080;

const jwtSecret: string = process.env.JWT_SECRET || randomString(32);
if (jwtSecret.length < 32) {
  logger.warn("Warning: the JWT secret key should be at least 32 characters long.");
}
const rootSecret: string = process.env.ROOT_SECRET || randomString(32);
if (!process.env.ROOT_SECRET) {
  logger.warn(`Warning: root password not set; autogenerated to ${rootSecret}`);
}
const organization: string = process.env.ORGANIZATION || "";
if (!organization) {
  logger.fatal(`Please set ORGANIZATION to the organization this node belongs to.`);
  process.exit(1);
}
const organizationVaultSecret: string = process.env.ORGANIZATION_VAULT_SECRET || "";
if (!organizationVaultSecret) {
  logger.fatal(
    `Please set ORGANIZATION_VAULT_SECRET to the secret key used to encrypt the organization's vault.`,
  );
  process.exit(1);
}

const SWAGGER_BASEPATH = process.env.SWAGGER_BASEPATH || "/";

/*
 * Initialize the components:
 */

const multichainHost = process.env.RPC_HOST || "localhost";
const backupApiPort = process.env.BACKUP_API_PORT || "8085";

const rpcSettings: ConnectionSettings = {
  protocol: "http",
  host: multichainHost,
  port: parseInt(process.env.RPC_PORT || "8000", 10),
  username: process.env.RPC_USER || "multichainrpc",
  password: process.env.RPC_PASSWORD || "s750SiJnj50yIrmwxPnEdSzpfGlTAHzhaUwgqKeb0G1j",
};

const env = process.env.NODE_ENV || "";

logger.info(
  { rpcSettings: rpcSettingsWithoutPassword(rpcSettings) },
  "Connecting to MultiChain node",
);
const db = Multichain.init(rpcSettings);
const { multichainClient } = db;

const server = createBasicApp(jwtSecret, URL_PREFIX, port, SWAGGER_BASEPATH, env);

/*
 * Run the app:
 */
// server.register(require('./'), { prefix: '/api' })

// Enable useful traces of unhandled-promise warnings:
process.on("unhandledRejection", err => {
  logger.fatal(err, "UNHANDLED PROMISE REJECTION");
  process.exit(1);
});

function registerSelf(): Promise<boolean> {
  return multichainClient
    .getRpcClient()
    .invoke("listaddresses", "*", false, 1, 0)
    .then(addressInfos =>
      addressInfos
        .filter(info => info.ismine)
        .map(info => info.address)
        .find(_ => true),
    )
    .then(address => {
      const req = {
        body: {
          data: {
            address,
            organization,
          },
        },
      };
      registerNode(multichainClient, req);
    })
    .then(() => true)
    .catch(() => false);
}

GroupCreate.addHttpHandler(server, URL_PREFIX, {
  createGroup: (ctx, user, group) => createGroup(db, ctx, user, group),
});

UserAuthenticate.addHttpHandler(
  server,
  URL_PREFIX,
  {
    authenticate: (ctx, userId, password) =>
      authenticate(organization, organizationVaultSecret, rootSecret, db, ctx, userId, password),
    getGroupsForUser: (ctx, serviceUser, userId) => getGroupsForUser(db, ctx, serviceUser, userId),
  },
  jwtSecret,
);

UserCreate.addHttpHandler(server, URL_PREFIX, {
  createUser: (ctx, user, group) => createUser(organizationVaultSecret, db, ctx, user, group),
});

GlobalPermissionGrant.addHttpHandler(server, URL_PREFIX, {
  grantGlobalPermission: (ctx, user, grantee, permission) =>
    grantGlobalPermission(db, ctx, user, grantee, permission),
});

GlobalPermissionGrantAll.addHttpHandler(server, URL_PREFIX, {
  getGlobalPermissions: (ctx, user) =>
    GetGlobalPermissionsService.getGlobalPermissions(db, ctx, user),
  grantGlobalPermissions: (ctx, user, grantee, permission) =>
    grantGlobalPermission(db, ctx, user, grantee, permission),
});

GlobalPermissionRevoke.addHttpHandler(server, URL_PREFIX, {
  revokeGlobalPermission: (ctx, user, revokee, permission) =>
    revokeGlobalPermission(db, ctx, user, revokee, permission),
});

ProjectCreate.addHttpHandler(server, URL_PREFIX, {
  createProject: (ctx, user, body) => createProject(db, ctx, user, body),
});

ProjectUpdate.addHttpHandler(server, URL_PREFIX, {
  updateProject: (ctx, user, projectId, reqData) =>
    updateProject(db, ctx, user, projectId, reqData),
});

ProjectPermissionsGrant.addHttpHandler(server, URL_PREFIX, {
  grantProjectPermission: (ctx, user, projectId, grantee, intent) =>
    grantProjectPermission(db, ctx, user, projectId, grantee, intent),
});

ProjectPermissionsRevoke.addHttpHandler(server, URL_PREFIX, {
  revokeProjectPermission: (ctx, user, projectId, grantee, intent) =>
    revokeProjectPermission(db, ctx, user, projectId, grantee, intent),
});

ProjectList.addHttpHandler(server, URL_PREFIX, {
  listProjects: (ctx, user) => listProjects(db, ctx, user),
});

SubprojectCreate.addHttpHandler(server, URL_PREFIX, {
  createSubproject: (ctx, user, body) => createSubproject(db, ctx, user, body),
});

SubprojectList.addHttpHandler(server, URL_PREFIX, {
  listSubprojects: (ctx, user, projectId) => listSubprojects(db, ctx, user, projectId),
});

server.listen(port, "0.0.0.0", async err => {
  if (err) {
    logger.fatal({ err }, "Connection could not be established. Aborting.");
    process.exit(1);
  }

  const retryIntervalMs = 5000;

  while (!(await isReady(multichainClient))) {
    logger.info(
      `MultiChain connection/permissions not ready yet. Trying again in ${retryIntervalMs / 1000}s`,
    );
    await timeout(retryIntervalMs);
  }

  while (
    !(await ensureOrganizationStream(multichainClient, organization!, organizationVaultSecret!)
      .then(() => true)
      .catch(() => false))
  ) {
    logger.info(
      { multichainClient, organization },
      `Failed to create organization stream. Trying again in ${retryIntervalMs / 1000}s`,
    );
    await timeout(retryIntervalMs);
  }
  logger.debug({ multichainClient, organization }, "Organization stream present");

  while (!(await registerSelf())) {
    logger.info(
      { multichainClient, organization },
      `Failed to register node. Trying again in ${retryIntervalMs / 1000}s`,
    );
    await timeout(retryIntervalMs);
  }
  logger.debug({ params: { multichainClient, organization } }, "Node registered in nodes stream");
});

function rpcSettingsWithoutPassword(settings) {
  const tmp = deepcopy(settings);
  delete tmp.password;
  return tmp;
}
